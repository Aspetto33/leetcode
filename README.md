# leetcode

2021/9/22

**题目**

修剪二叉搜索树，将值不在界限范围内的节点删除

**思路**

1.返回值及参数

因为要返回树的结构，所以返回值为Treenode类型的，参数为root。

2.终止条件

当root是空节点的时候，返回空。

3.单层递归逻辑

当root的值小于low时，寻找右子树中符合值大于low的节点，将其返回；当root的值大于high时，寻找左子树中符合值小于high的节点，将其返回。递归左右子树。

**题目**

将有序数组转换为二叉搜索树，有序数组是递增的。

**思路**

1.返回值及参数

因为要返回树的结构，所以返回类型为Treenode，因为要有左右边界，所以参数应该有数组、left、right。

2.终止条件

当左边界大于右边界的时候，说明递归结束

3.单层递归逻辑

因为二叉搜索树中序遍历后的数组是递增的，所以数组中间值即为根结点的值。因此求出数组中间索引的值，然后将其指向的数据赋给新声明的根节点，然后左子树的边界为数组的开始到数组中间的前一个数据；右子树的边界为数组中间的后一个数据到数组末尾。

**题目**

把二叉搜索树转换为累加树

**思路**

仔细观察给的示例发现是按照右、中、左的顺序进行累加。因此可以用一个指针记录前一个节点的值，让指针移动以此实现累加。

1.返回值及参数

因为是循环遍历整棵树累加，所以可以没有返回值，参数为root

2.终止条件

当root为空的时候返回空。

3.单层递归逻辑

右递归、当前节点的值累加上一个节点的值，然后将当前结点的值赋给指针、左递归。

2021/9/23

**题目**

组合，将从1到n中的数取k个组成不同的组合，组合没有顺序，因此元素不同顺序排列的组合是同一个，即只要组合内的元素一样，即为同一个组合。

**思路**

从组合为[1,n]中取k个数可以组成多少组合的题目可以使用回溯法。如果使用嵌套for循环时，需要有k层for循环，因此，for循环方法不可行。虽然回溯法也是暴力解法，但是该方法可以解决此类问题。

1.回溯函数返回值及参数

回溯函数一般没有返回值，即void。需要有集合的边界n、选取几个数k、还需要有一个开始索引startIndex，记录从哪里开始选取数。

2.确定回溯终止条件

声明两个公共成员变量，path为记录单个结果的变量，result记录最终结果，当path的size等于k时，终止，将path变量push进result中。

3.单层回溯逻辑

循环遍历数组，开始为startIndex，结束为n，将值push进path中，然后进行回溯，回溯的最后一个参数为当前元素的后一个，即startIndex等于当前元素的后一个元素所在位置的索引。然后path进行回溯，将当前元素pop出来。

2021/9/24

**题目**

从1到9（包括1和9）取出k个数，使其和相加为n。

**思路**

该题可以使用回溯法，横向遍历1到9，纵向递归。

1.确定回溯函数返回值及参数

回溯函数一般没有返回值，参数是写回溯函数时边写边加的，首先需要n、k，其次需要一个开始索引startIndex

2.终止条件

指定两个公共成员变量，一个存放最终结果，一个存放当前结果。存放当前结果的path数组如果长度达到k并且n的值为0，则将path push进result中。

3.单层回溯逻辑

首先需要从开始索引遍历到9，使n减去当前的i，然后将i push进path中，从i+1开始递归。因为n减去了i，所以要回溯再加上i，push进path中的i要再pop出来。

2021/9/27

**题目**

![image-20210927210853362](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20210927210853362.png)

**思路**

横向遍历数字对应的所有字符，纵向递归。设定两个全局变量：一个为path，记录一种字母组合；一个为result，记录最终结果。当path的size等于给定的数字字符的长度时，将path push进result中，结束。使用index来记录数字字符的索引，将index处的数字字符转化为整形，通过数字找到对应的字符然后遍历字符，将i位置的字符push进path中，然后递归，最后回溯。最后别忘记判断当给定数字字符的大小为0时，直接返回空数组。

2021/9/28

**题目**

![image-20210928213520998](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20210928213520998.png)

**思路**

组合总和可以用回溯法解决。横向遍历给定的int型数组，纵向递归。

可以用target减去数组元素，当target小于0时终止，当target等于0时将满足条件的组合push进result数组中。i从startIndex开始，终止为数组的size，循环。将数组元素push进记录当前组合的数组中，然后令target减去数组元素的值，从i开始递归，因为数组元素可以重复，然后回溯target，之后回溯记录当前数组元素的数组。

2021/9/28

**题目**

![image-20210929111431656](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20210929111431656.png)

**思路**

此题最重要的是去重。组合内可以有元素重复，但是因为组合没有顺序之说，即只要组合内元素相同，则组合相同，因此需要在树的同一层去重。比如[1,1,2],选取1之后同一层则不能再选择1。使用一个存储bool类型元素的数组记录用过的元素。如果used[i-1]==true，则说明该元素在本层没有用过，反之则跳过。重要的一点是需要将数组内的元素进行排序，将相同元素放在一起。

2021/9/30

**题目**

![image-20210930203144631](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20210930203144631.png)

**思路**

如示例，在第一个a处切割，剩下的在ab中选择；

​				在aa处切割，剩下的在b中选择。

此过程类似组合问题的解决过程。因此可以用回溯。切割线为startIndex，选取的字符串即为[startIndex,i)范围的字符串，判断此字符串是否为回文，如果是，则放入path数组中，否则跳过。判断回文字符串的方法可以用双指针，一个指针指向字符串头，一个指向尾，循环判断，如果其中有不相等的则返回false，否则，返回true。终止条件是当切割线到达字符串的最后，则说明找到符合条件的切割方法了。

2021/10/1

**题目**



![image-20211001220136544](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20211001220136544.png)

**思路**

本题类似回文切割，需要有一个切割线来记录切割位置，同时还需要有一个计数器来记录插入了多少个.。首先判断startIndex到i区间的字符串是否符合要求，如果符合要求则插入点，并且pointiNum+1，然后递归，回溯。终止条件是当pointNum等于3时，这时候说明字符串已经被分为四段了，然后判断第四段是否符合规则，如果符合则push进最终结果集中。字符串不符合规则有以下几种情况：

​			1.以0开头，且不是0.0.0.0

​			2.不是数字字符，即大于9或者小于0

​			3.该字符串大于255

2021/10/2

**题目**

求数组中元素的所有子集，而且不能重复，即只要子集元素相同即为同一个子集。

**思路**

同样是求组合，因此可以使用回溯法，但是本题可以不用终止条件，因为是求所有子集，所以循环中当i>数组大小时，循环已经结束了。

2021/10/3

**题目**

同上题大体类似，只是数组中含有重复元素。

**思路**

思路同上题大体类似，只是需要在同一树层进行去重操作，即判断元素在此之前是否用过，若用过则跳过，否则进行下面的操作。去重操作需要将数组元素进行排序使得相同的元素连续排列，此时可以用判断前后元素是否相同，以及用来记录该元素是否使用过的used数组进行重复判断。若used数组记录的前一个元素的值为false，则说明此元素被使用过，即跳过。

2021/10/4

**题目**

求所给数组的所有递增子序列。

**思路**

同求所有子集不同的是，在求子集的基础上要求子集是递增的，且数组中含有重复元素，因此要在同一树层进行去重操作。

之前的去重操作是需要将数组进行排序之后才能去重，本题如果也这样做，那么本身就是递增的数组，所求的子集也必然是递增的，这样做失去了本题原本的意义。因此可以使用unordered_set记录已经使用过的元素，以此来实现去重操作。

2021/10/5

**题目**

求一个数组所有可能的全排列。

**思路**

排列不同于集合的地方在于排列是有顺序的，即使元素相同，但只要排列顺序不同也是不同的排列。因此可以用一个bool类型的数组来记录哪些元素用过，哪些没用过，直到记录每一个符合条件的数组大小等于nums大小。

2021/10/6

**题目**

求一个数组的所有可能全排列，数组中含有重复元素。

**思路**

本题与上一题的不同之处在于本题的数组中有重复元素，因此在同一层树中需要进行去重操作。从第二个元素起，如果等于前一个元素，且用来记录元素是否用过的数组的前一个元素值为false，此时应该跳过该数，用下一个数。

2021/10/8

**题目**

一些有大小之分的饼干要分给不同胃口的小孩，如果饼干的大小大于等于小孩的胃口，则此饼干可以分给该小孩。尽可能让更多的小孩吃到饼干。

**思路**

该题可以使用贪心算法，通过“饼干的大小满足小孩的胃口”这样的局部最优，以此来达到“让更多的小孩得到饼干”这个全局最优解法。先将记录饼干大小和小孩胃口两个数组排序，然后记录饼干大小数组最后一个元素的索引，从后往前循环遍历小孩胃口，如果索引存在并且饼干的大小可以满足小孩的胃口，则将计数器的值加1，从记录饼干大小数组的倒数第二个开始继续判断，即令索引值减一，以此类推，最后返回记录结果的计数器。
