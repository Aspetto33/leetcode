# leetcode

2021/9/22

**题目**

修剪二叉搜索树，将值不在界限范围内的节点删除

**思路**

1.返回值及参数

因为要返回树的结构，所以返回值为Treenode类型的，参数为root。

2.终止条件

当root是空节点的时候，返回空。

3.单层递归逻辑

当root的值小于low时，寻找右子树中符合值大于low的节点，将其返回；当root的值大于high时，寻找左子树中符合值小于high的节点，将其返回。递归左右子树。

**题目**

将有序数组转换为二叉搜索树，有序数组是递增的。

**思路**

1.返回值及参数

因为要返回树的结构，所以返回类型为Treenode，因为要有左右边界，所以参数应该有数组、left、right。

2.终止条件

当左边界大于右边界的时候，说明递归结束

3.单层递归逻辑

因为二叉搜索树中序遍历后的数组是递增的，所以数组中间值即为根结点的值。因此求出数组中间索引的值，然后将其指向的数据赋给新声明的根节点，然后左子树的边界为数组的开始到数组中间的前一个数据；右子树的边界为数组中间的后一个数据到数组末尾。

**题目**

把二叉搜索树转换为累加树

**思路**

仔细观察给的示例发现是按照右、中、左的顺序进行累加。因此可以用一个指针记录前一个节点的值，让指针移动以此实现累加。

1.返回值及参数

因为是循环遍历整棵树累加，所以可以没有返回值，参数为root

2.终止条件

当root为空的时候返回空。

3.单层递归逻辑

右递归、当前节点的值累加上一个节点的值，然后将当前结点的值赋给指针、左递归。

2021/9/23

**题目**

组合，将从1到n中的数取k个组成不同的组合，组合没有顺序，因此元素不同顺序排列的组合是同一个，即只要组合内的元素一样，即为同一个组合。

**思路**

从组合为[1,n]中取k个数可以组成多少组合的题目可以使用回溯法。如果使用嵌套for循环时，需要有k层for循环，因此，for循环方法不可行。虽然回溯法也是暴力解法，但是该方法可以解决此类问题。

1.回溯函数返回值及参数

回溯函数一般没有返回值，即void。需要有集合的边界n、选取几个数k、还需要有一个开始索引startIndex，记录从哪里开始选取数。

2.确定回溯终止条件

声明两个公共成员变量，path为记录单个结果的变量，result记录最终结果，当path的size等于k时，终止，将path变量push进result中。

3.单层回溯逻辑

循环遍历数组，开始为startIndex，结束为n，将值push进path中，然后进行回溯，回溯的最后一个参数为当前元素的后一个，即startIndex等于当前元素的后一个元素所在位置的索引。然后path进行回溯，将当前元素pop出来。

2021/9/24

**题目**

从1到9（包括1和9）取出k个数，使其和相加为n。

**思路**

该题可以使用回溯法，横向遍历1到9，纵向递归。

1.确定回溯函数返回值及参数

回溯函数一般没有返回值，参数是写回溯函数时边写边加的，首先需要n、k，其次需要一个开始索引startIndex

2.终止条件

指定两个公共成员变量，一个存放最终结果，一个存放当前结果。存放当前结果的path数组如果长度达到k并且n的值为0，则将path push进result中。

3.单层回溯逻辑

首先需要从开始索引遍历到9，使n减去当前的i，然后将i push进path中，从i+1开始递归。因为n减去了i，所以要回溯再加上i，push进path中的i要再pop出来。

2021/9/27

**题目**

![image-20210927210853362](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20210927210853362.png)

**思路**

横向遍历数字对应的所有字符，纵向递归。设定两个全局变量：一个为path，记录一种字母组合；一个为result，记录最终结果。当path的size等于给定的数字字符的长度时，将path push进result中，结束。使用index来记录数字字符的索引，将index处的数字字符转化为整形，通过数字找到对应的字符然后遍历字符，将i位置的字符push进path中，然后递归，最后回溯。最后别忘记判断当给定数字字符的大小为0时，直接返回空数组。

2021/9/28

**题目**

![image-20210928213520998](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20210928213520998.png)

**思路**

组合总和可以用回溯法解决。横向遍历给定的int型数组，纵向递归。

可以用target减去数组元素，当target小于0时终止，当target等于0时将满足条件的组合push进result数组中。i从startIndex开始，终止为数组的size，循环。将数组元素push进记录当前组合的数组中，然后令target减去数组元素的值，从i开始递归，因为数组元素可以重复，然后回溯target，之后回溯记录当前数组元素的数组。

2021/9/28

**题目**

![image-20210929111431656](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20210929111431656.png)

**思路**

此题最重要的是去重。组合内可以有元素重复，但是因为组合没有顺序之说，即只要组合内元素相同，则组合相同，因此需要在树的同一层去重。比如[1,1,2],选取1之后同一层则不能再选择1。使用一个存储bool类型元素的数组记录用过的元素。如果used[i-1]==true，则说明该元素在本层没有用过，反之则跳过。重要的一点是需要将数组内的元素进行排序，将相同元素放在一起。

2021/9/30

**题目**

![image-20210930203144631](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20210930203144631.png)

**思路**

如示例，在第一个a处切割，剩下的在ab中选择；

​				在aa处切割，剩下的在b中选择。

此过程类似组合问题的解决过程。因此可以用回溯。切割线为startIndex，选取的字符串即为[startIndex,i)范围的字符串，判断此字符串是否为回文，如果是，则放入path数组中，否则跳过。判断回文字符串的方法可以用双指针，一个指针指向字符串头，一个指向尾，循环判断，如果其中有不相等的则返回false，否则，返回true。终止条件是当切割线到达字符串的最后，则说明找到符合条件的切割方法了。

2021/10/1

**题目**



![image-20211001220136544](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20211001220136544.png)

**思路**

本题类似回文切割，需要有一个切割线来记录切割位置，同时还需要有一个计数器来记录插入了多少个.。首先判断startIndex到i区间的字符串是否符合要求，如果符合要求则插入点，并且pointiNum+1，然后递归，回溯。终止条件是当pointNum等于3时，这时候说明字符串已经被分为四段了，然后判断第四段是否符合规则，如果符合则push进最终结果集中。字符串不符合规则有以下几种情况：

​			1.以0开头，且不是0.0.0.0

​			2.不是数字字符，即大于9或者小于0

​			3.该字符串大于255

2021/10/2

**题目**

求数组中元素的所有子集，而且不能重复，即只要子集元素相同即为同一个子集。

**思路**

同样是求组合，因此可以使用回溯法，但是本题可以不用终止条件，因为是求所有子集，所以循环中当i>数组大小时，循环已经结束了。

2021/10/3

**题目**

同上题大体类似，只是数组中含有重复元素。

**思路**

思路同上题大体类似，只是需要在同一树层进行去重操作，即判断元素在此之前是否用过，若用过则跳过，否则进行下面的操作。去重操作需要将数组元素进行排序使得相同的元素连续排列，此时可以用判断前后元素是否相同，以及用来记录该元素是否使用过的used数组进行重复判断。若used数组记录的前一个元素的值为false，则说明此元素被使用过，即跳过。

2021/10/4

**题目**

求所给数组的所有递增子序列。

**思路**

同求所有子集不同的是，在求子集的基础上要求子集是递增的，且数组中含有重复元素，因此要在同一树层进行去重操作。

之前的去重操作是需要将数组进行排序之后才能去重，本题如果也这样做，那么本身就是递增的数组，所求的子集也必然是递增的，这样做失去了本题原本的意义。因此可以使用unordered_set记录已经使用过的元素，以此来实现去重操作。

2021/10/5

**题目**

求一个数组所有可能的全排列。

**思路**

排列不同于集合的地方在于排列是有顺序的，即使元素相同，但只要排列顺序不同也是不同的排列。因此可以用一个bool类型的数组来记录哪些元素用过，哪些没用过，直到记录每一个符合条件的数组大小等于nums大小。

2021/10/6

**题目**

求一个数组的所有可能全排列，数组中含有重复元素。

**思路**

本题与上一题的不同之处在于本题的数组中有重复元素，因此在同一层树中需要进行去重操作。从第二个元素起，如果等于前一个元素，且用来记录元素是否用过的数组的前一个元素值为false，此时应该跳过该数，用下一个数。

2021/10/8

**题目**

一些有大小之分的饼干要分给不同胃口的小孩，如果饼干的大小大于等于小孩的胃口，则此饼干可以分给该小孩。尽可能让更多的小孩吃到饼干。

**思路**

该题可以使用贪心算法，通过“饼干的大小满足小孩的胃口”这样的局部最优，以此来达到“让更多的小孩得到饼干”这个全局最优解法。先将记录饼干大小和小孩胃口两个数组排序，然后记录饼干大小数组最后一个元素的索引，从后往前循环遍历小孩胃口，如果索引存在并且饼干的大小可以满足小孩的胃口，则将计数器的值加1，从记录饼干大小数组的倒数第二个开始继续判断，即令索引值减一，以此类推，最后返回记录结果的计数器。

2021/10/14

**题目**

给定一个数组，如果数组连续的数相减的差组成的数组的正负是相间隔的，则说明是摆动序列，第一个差可以是正数或者负数，如果数组有一个或者两个不相等的数，则摆动序列含有元素数量等于数组大小。求摆动序列的大小。

**思路**

![376.摆动序列](https://img-blog.csdnimg.cn/20201124174327597.png)

​	如果一个数在单调的线上则把这个数跳过，不包含头尾两个数，但是要考虑一种情况，如果连续的	两个数相等，差为0的时候，此时也应该算，可以把记录结果的变量的初始值设为1，即默认最后有	一个摆动序列。用一个整形指针记录当前差，另一个整形指针记录前一个差，如果符合摆动序列的条件，则令preDiff等于curDiff，否则什么都不做，最后返回result。

2021/10/18

**题目**

​	给定一个数组，元素有正有负，求最大和的连续子序列，并返回最大和。

**思路**

​	因为数组内元素有正有负，所以最大和必然为正数，所以可以利用这个规律，声明一个记录最终结果的变量，令其初始值为整数里的最小值或者是数组第一个元素的值，声明另一个变量动态记录序列和。如果序列和大于0，此时可以继续往下加数组元素值；否则，应该重置序列第一个元素，令sum等于当前数组元素值。

2021/10/19

**题目**

​	给定一个数组记录每天股票的价格，手中只能有一支股票，即手中的出售后才能买下一个，求最大	利润。

**思路**

​	假定股票在第一天买入，第三天卖出的利润是最大的，则只需求prices[2] - prices[0]。同时上式可	以分解为（prices[2] - prices[1]）+(prices[1]-prices[0])。即只需将数组连续两个元素的差为正数的	相加即可达到最大利润。

2021/10/20

**题目**

​	给定一个数组，里面的元素值表示当前位置可以往后走的步数，判断给定的数组是否可以走到最后	一步，如果可以返回true，否则返回false。

**思路**

​	声明一个变量记录当前位置可以往后走的最大步数，每次判断此值是否大于等于数组最后元素下标值，如果是返回true，如果循环完毕没有返回值，则返回false。记录最大步数的变量每次要加当前下标值，因为已经在此位置。

2021/10/21

**题目**

​	同昨天的题，但是一定可达，同时在使用最少步数的前提下走到数组末尾。

**思路**

​	在元素指定区间内寻找最大可走步数，最终达到用最少的步数走到最后。

​	声明一个变量记录当前元素指定区间的最大元素，另一个变量记录走到最后的步数，还有一个变量记录边界。循环遍历数组到倒数第二个元素，因为一定可达，所以最后到达的位置一定是在最后一个元素处或者其后面。如果指针到达边界，则步数就要加1，并且更新边界值。最后返回走的步数。

2021/10/22

**题目**

​	给定一个数组和一个k值，将索引为i的数变为相反数，i可以多次选择，保证选择数为k，然后求变换之后数组的最大和。

**思路**

​	首先可以将数组按照绝对值大小从大到小排序，然后遍历排序之后的数组，如果数组元素小于0并且k大于0，则将数组元素变为其相反值，同时k减1。循环之后如果k为奇数则将数组最后一个元素变为相反数，如果为偶数则说明剩下的正数是从正数变为负数再变为正数，因此可以忽略不计。最后求和。

2021/10/24

**题目**

​	给定一个记录可以加多少油量的数组gas和一个耗费多少油量的数组cost，判断是否有一个出发点可以使得汽车从此出发点出发可以回到出发点。

**思路**

​	暴力解法：第一重循环遍历数组，寻找可以到达的出发点i

​	第二重循环使用while循环遍历，判断i索引处出发是否可以再回到出发点。

​	二重循环完成后如果剩余油量大于等于0并且二重循环停留的索引值等于i值，则返回此i

​	如果一重循环结束之后仍然没有返回值，此时则返回-1。

2021/10/25

**题目**

​	给定一个记录面币大小的数组，一杯柠檬水的价格是5元，判断一直到数组最后一个元素是否能够成功找零，面币大小只有5、10、20三种。

**思路**

​	因为只有三种面币大小，所以可以模拟过程。声明三个变量分别记录收到的5、10、20的数量，当收到的是5元时，record5加一；当收到的是10元时，判断是否有大于等于1张的5元纸币，如果有则record5--，record10++，否则返回false；当收到的是20元时，优先判断是否有大于0张的5元和10元纸币（因为10元纸币只能找给收到的纸币大小是20元的情况），如果有则record5--，record10--，record20++，否则判断是否有大于等于三张的5元纸币，如果有则record5-3，否则返回false。
